package api

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"strings"
	"time"
)

const apiURL = "https://query1.finance.yahoo.com/v7/finance/quote?lang=en-US&region=US&corsDomain=finance.yahoo.com&fields=symbol,marketState,regularMarketPrice,regularMarketChange,regularMarketChangePercent,preMarketPrice,preMarketChange,preMarketChangePercent,postMarketPrice,postMarketChange,postMarketChangePercent"

// AutoGenerated struct from API response
// https://mholt.github.io/json-to-go/
type AutoGenerated struct {
	QuoteResponse QuoteResponse `json:"quoteResponse"`
}

// Result autogenerated
type Result struct {
	Language                   string  `json:"language"`
	Region                     string  `json:"region"`
	QuoteType                  string  `json:"quoteType"`
	QuoteSourceName            string  `json:"quoteSourceName"`
	Triggerable                bool    `json:"triggerable"`
	SourceInterval             int     `json:"sourceInterval"`
	ExchangeDataDelayedBy      int     `json:"exchangeDataDelayedBy"`
	FirstTradeDateMilliseconds int64   `json:"firstTradeDateMilliseconds"`
	PriceHint                  int     `json:"priceHint"`
	PreMarketChangePercent     float64 `json:"preMarketChangePercent"`
	PreMarketTime              int     `json:"preMarketTime"`
	PreMarketPrice             float64 `json:"preMarketPrice"`
	PreMarketChange            float64 `json:"preMarketChange"`
	PostMarketChangePercent    float64 `json:"postMarketChangePercent"`
	PostMarketTime             int     `json:"postMarketTime"`
	PostMarketPrice            float64 `json:"postMarketPrice"`
	PostMarketChange           float64 `json:"postMarketChange"`
	RegularMarketChange        float64 `json:"regularMarketChange"`
	RegularMarketChangePercent float64 `json:"regularMarketChangePercent"`
	RegularMarketTime          int     `json:"regularMarketTime"`
	RegularMarketPrice         float64 `json:"regularMarketPrice"`
	RegularMarketPreviousClose float64 `json:"regularMarketPreviousClose"`
	FullExchangeName           string  `json:"fullExchangeName"`
	ExchangeTimezoneName       string  `json:"exchangeTimezoneName"`
	ExchangeTimezoneShortName  string  `json:"exchangeTimezoneShortName"`
	GmtOffSetMilliseconds      int     `json:"gmtOffSetMilliseconds"`
	Market                     string  `json:"market"`
	EsgPopulated               bool    `json:"esgPopulated"`
	MarketState                string  `json:"marketState"`
	Exchange                   string  `json:"exchange"`
	Tradeable                  bool    `json:"tradeable"`
	Symbol                     string  `json:"symbol"`
}

// QuoteResponse autogenerated
type QuoteResponse struct {
	Result []Result    `json:"result"`
	Error  interface{} `json:"error"`
}

// Call makes HTTP request for stock data
func Call(symbols []string) map[string]Result {
	if len(symbols) == 0 {
		return nil
	}

	client := http.DefaultClient

	if client.Jar == nil {
		jar, err := cookiejar.New(nil)
		if err != nil {
			log.Fatal(err)
		}
		client.Jar = jar

		req, err := http.NewRequest("GET", "https://finance.yahoo.com", nil)
		if err != nil {
			log.Fatal(err)
		}
		setHeaders(req)
		_, err = client.Do(req)
		if err != nil {
			log.Fatal(err)
		}
	}

	url, _ := url.Parse(apiURL)
	qp := url.Query()

	crumb, err := getCrumb(client)
	if err != nil {
		log.Fatal(err)
	}
	qp.Add("crumb", crumb)
	qp.Add("symbols", strings.Join(symbols, ","))
	url.RawQuery = qp.Encode()

	req, err := http.NewRequest("GET", url.String(), nil)
	if err != nil {
		log.Fatalln(err)
	}
	setHeaders(req)

	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}

	if resp.StatusCode >= 300 {
		log.Printf("API response status code non 200: %d %s\n", resp.StatusCode, resp.Status)
		return nil
	}

	defer resp.Body.Close()

	var buf bytes.Buffer
	tee := io.TeeReader(resp.Body, &buf)

	var reader io.Reader
	reader, err = gzip.NewReader(tee)
	if err != nil {
		reader = &buf
	}
	body, err := ioutil.ReadAll(reader)
	if err != nil {
		log.Fatal(err)
	}

	var autogen AutoGenerated
	err = json.Unmarshal(body, &autogen)
	if err != nil {
		log.Fatal("body unmarshal", err)
	}

	ret := make(map[string]Result)
	for _, v := range autogen.QuoteResponse.Result {
		ret[v.Symbol] = v
	}

	return ret
}

func setHeaders(req *http.Request) {
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0")
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	req.Header.Set("Accept-Encoding", "gzip, deflate, br")
	req.Header.Set("DNT", "1")
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("Upgrade-Insecure-Requests", "1")
	req.Header.Set("Sec-Fetch-Dest", "document")
	req.Header.Set("Sec-Fetch-Mode", "navigate")
	req.Header.Set("Sec-Fetch-Site", "none")
	req.Header.Set("Sec-Fetch-User", "?1")
}

func getCrumb(client *http.Client) (string, error) {
	t := time.Now()
	n := 2
	if float64(t.Nanosecond())/1e9 >= 0.5 {
		n = 1
	}
	url := fmt.Sprintf("https://query%d.finance.yahoo.com/v1/test/getcrumb", n)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return "", err
	}
	setHeaders(req)
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	body, err := ioutil.ReadAll(resp.Body)
	defer resp.Body.Close()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(body)), nil
}
